<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>TAP: The Argument Parser</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TAP
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">The Argument Parser </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_intro"></a>
Introduction</h1>
<p>This is <a class="el" href="de/dd0/namespaceTAP.html" title="The main TAP namespace. ">TAP</a>, a library for command line argument parsing ala get_opt_long(). It is a header-only library with a bunch of templated classes that ought to make argument parsing simple. The main reasons for the existence of this library:</p>
<ul>
<li>Simple to install, drop in the headers and done;</li>
<li>Ability to store argument variables directly into passed variables, or internally in the argument data;</li>
<li>Attempt to somewhat separate the notion of constraints;</li>
<li>Something that uses a bit more recent C++ dialect (C++14);</li>
<li>It does mostly the same as anything else, but slightly different.</li>
</ul>
<p>Try before you buy, check some of the examples, and otherwise look at for instance boost::program_options, TCLAP, get_opt() (ha), "The Lean Mean C++ Option Parser", cpp-optparse, or just check <a href="http://stackoverflow.com/questions/865668/parse-command-line-arguments">http://stackoverflow.com/questions/865668/parse-command-line-arguments</a>.</p>
<h1><a class="anchor" id="sec_install"></a>
Installation</h1>
<p>As this is a header-only library, no install is necessary. Just drop the directory 'tap' with all headers somewhere in your include path, and all should be fine.</p>
<h1><a class="anchor" id="sec_usage"></a>
Usage</h1>
<p>To use the library, first add a </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="d6/db2/Tap_8h.html">tap/Tap.h</a>&gt;</span></div>
</div><!-- fragment --><p> to your sources, then simply code away. All members of <a class="el" href="de/dd0/namespaceTAP.html" title="The main TAP namespace. ">TAP</a> are defined in the <a class="el" href="de/dd0/namespaceTAP.html" title="The main TAP namespace. ">TAP</a> namespace.</p>
<p>Quickstart: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="d6/db2/Tap_8h.html">tap/Tap.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">    <a class="code" href="d4/dfb/classTAP_1_1Argument.html">TAP::Argument</a> badExit(<span class="stringliteral">&quot;If set, exit with non-zero status&quot;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="stringliteral">&quot;badexit&quot;</span>);</div>
<div class="line">    <a class="code" href="d1/da2/classTAP_1_1ArgumentParser.html">TAP::ArgumentParser</a> parser(badExit);</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        parser.parse(argc, argv);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="d2/d5e/classTAP_1_1exception.html">TAP::exception</a>&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; e.<a class="code" href="d2/d5e/classTAP_1_1exception.html#a857656e150962297f4ca2b1b10694c87">what</a>() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (badExit) {</div>
<div class="line">        <span class="comment">// The argument was set</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Just, why?&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_tutorial"></a>
Tutorial and examples</h1>
<p>Argument parsing starts with defining a number of <a class="el" href="d4/dfb/classTAP_1_1Argument.html" title="Simple argument class. ">TAP::Argument</a> instances, adding them to an <a class="el" href="d1/da2/classTAP_1_1ArgumentParser.html" title="Argument parser class. ">TAP::ArgumentParser</a>, and passing along the actual program arguments (as received from main()) to the parser. If all goes well, you can read in the parsed data from the arguments, otherwise an <a class="el" href="d2/d5e/classTAP_1_1exception.html" title="Standard exception class for TAP. ">TAP::exception</a> will be thrown.</p>
<p>The examples below assume TAP_AUTOFLAG has been defined, see <a class="el" href="index.html#sec_config">Configuration</a> for details.</p>
<h2><a class="anchor" id="sec_argdef"></a>
Defining arguments</h2>
<p>At the basic level, an argument consists of a description, and zero or more aliases. Aliases can be used to name the argument on the command line, either as a flag or as a name (see <a class="el" href="d1/da2/classTAP_1_1ArgumentParser.html" title="Argument parser class. ">TAP::ArgumentParser</a> for details). One particular remark about aliases: If an argument is created without an alias, it is marked as positional. Any alias defined later does not change this. This allows positional arguments to be defined, that can also be accessed via a name or flag.</p>
<p>The description can be used to define aliases as well. To do so, mark the flags or names to use in the description (see <a class="el" href="d4/dfb/classTAP_1_1Argument.html#a3a174d0564f55efb4e022e60f10f56c2" title="When TAP_AUTOFLAG is defined, this function finds flag and/or name markers in the description of the ...">TAP::Argument::parse_description()</a>). You can use this to save on typing when defining arguments.</p>
<p>Multiple argument classes exist that can be used, in short they are</p>
<ul>
<li>Argument: Simple argument class that can only be marked as set. They always have an alias associated with them.<div class="fragment"><div class="line"><span class="comment">// These two arguments are equivalent</span></div>
<div class="line"><a class="code" href="d4/dfb/classTAP_1_1Argument.html">TAP::Argument</a> a1(<span class="stringliteral">&quot;Show this help text&quot;</span>, <span class="charliteral">&#39;h&#39;</span>, <span class="stringliteral">&quot;help&quot;</span>);</div>
<div class="line"><a class="code" href="d4/dfb/classTAP_1_1Argument.html">TAP::Argument</a> a2(<span class="stringliteral">&quot;Show this &amp;help text&quot;</span>);</div>
</div><!-- fragment --></li>
<li>VariableArgument: Argument that can be assigned a value on the command line, which is stored in a variable that is given to the argument.<div class="fragment"><div class="line"><span class="keywordtype">int</span> optimization = 1; <span class="comment">// This also defines the default value.</span></div>
<div class="line"><a class="code" href="d4/dea/classTAP_1_1VariableArgument.html">TAP::VariableArgument&lt;int&gt;</a> optimizeLevel(<span class="stringliteral">&quot;Set &amp;optimization level&quot;</span>, optimization);</div>
</div><!-- fragment --></li>
<li>ValueArgument: Like VariableArgument, but stores the value internally. <div class="fragment"><div class="line"><span class="comment">// Initialize with default value 1</span></div>
<div class="line"><a class="code" href="de/d2e/classTAP_1_1ValueArgument.html">TAP::ValueArgument&lt;int&gt;</a> optimizeLevel(<span class="stringliteral">&quot;Set &amp;optimization level&quot;</span>, 1);</div>
</div><!-- fragment --></li>
<li>MultiVariableArgument, MultiValueArgument: Like above, but can occur multiple times on the command line, and each occurrence is stored separately. An std::vector is used to store these values. <div class="fragment"><div class="line"><a class="code" href="de/d2e/classTAP_1_1ValueArgument.html">TAP::MultiValueArgument&lt;std::string&gt;</a> includes(<span class="stringliteral">&quot;%Include these files&quot;</span>);</div>
<div class="line">...</div>
<div class="line">const std::string&amp; firstFile = includes.value()[0];</div>
</div><!-- fragment --></li>
<li>ConstArgument: Like Argument, but when it occurs, writes a constant value to a variable that is given to the argument. <div class="fragment"><div class="line"><span class="keyword">enum class</span> LogLevel {DEBUG, INFO, ERROR};</div>
<div class="line">LogLevel logLevel = LogLevel::INFO; <span class="comment">// default to info</span></div>
<div class="line"><a class="code" href="db/d23/classTAP_1_1ConstArgument.html">TAP::ConstArgument&lt;LogLevel&gt;</a> debugLevel(<span class="stringliteral">&quot;Set &amp;debug level&quot;</span>, logLevel, LogLevel::DEBUG);</div>
<div class="line"><a class="code" href="db/d23/classTAP_1_1ConstArgument.html">TAP::ConstArgument&lt;LogLevel&gt;</a> infoLevel(<span class="stringliteral">&quot;Set &amp;info level&quot;</span>, logLevel, LogLevel::INFO);</div>
<div class="line"><a class="code" href="db/d23/classTAP_1_1ConstArgument.html">TAP::ConstArgument&lt;LogLevel&gt;</a> errorLevel(<span class="stringliteral">&quot;Set &amp;error level&quot;</span>, logLevel, LogLevel::ERROR);</div>
</div><!-- fragment --></li>
<li>SwitchArgument: Like Argument, but keeps track of a boolean value, either internally or externally, that is switched each time it occurs. <div class="fragment"><div class="line"><span class="keywordtype">bool</span> do_daemonize = <span class="keyword">false</span>; <span class="comment">// default to false</span></div>
<div class="line"><a class="code" href="d8/d23/classTAP_1_1SwitchArgument.html">TAP::SwitchArgument</a> daemonize(<span class="stringliteral">&quot;Fork to background&quot;</span>, <span class="charliteral">&#39;d&#39;</span>, do_daemonize);</div>
<div class="line"><span class="comment">// restart defaults to true, so if set will switch to false</span></div>
<div class="line"><span class="comment">// note: this is a terrible way to interact</span></div>
<div class="line"><a class="code" href="d8/d23/classTAP_1_1SwitchArgument.html">TAP::SwitchArgument</a> restart(<span class="stringliteral">&quot;Do not &amp;restart on error&quot;</span>, <span class="keyword">true</span>);</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="sec_argreq"></a>
Required arguments and argument counts</h2>
<p>By default, all arguments are optional, and can occur at most once. To change this behavior, each argument has the following functions:</p>
<ul>
<li>set_required() : Require the argument to occur at least once</li>
<li>many() : Allow the argument to occur an unbounded amount of times</li>
<li>min(N) : Require the argument to occur at least N times</li>
<li>max(N) : Allow the argument to occur at most N times</li>
</ul>
<p>Regular arguments by default are optional and can occur at most once. Multi* arguments can occur many times. Note that for most TypedArgument types (except Multi*), if the argument is allowed to occur multiple times, its value is overwritten on each occurrence.</p>
<p>A common occurrence of arguments that are allowed to occur multiple times, but sometimes limited, are verbosity or debugging level arguments. For example: </p>
<div class="fragment"><div class="line"><a class="code" href="d4/dfb/classTAP_1_1Argument.html">TAP::Argument</a> verbosity(<span class="stringliteral">&quot;Set the verbosity level&quot;</span>, <span class="charliteral">&#39;v&#39;</span>, <span class="stringliteral">&quot;verbose&quot;</span>);</div>
<div class="line">verbosity.max(3); <span class="comment">// alternatively: many()</span></div>
<div class="line">...</div>
<div class="line">if (verbosity) {</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> verbosityLevel = verbosity.count();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that there is a (small) semantic difference between a required argument and the minimum number of occurrences. If required() is true, this only means the argument has to occur somewhere. The min() value dictates how many times. If required() is false, the argument is also alowed to be absent, even if min is not zero. In fact, min is required to be always at least 1.</p>
<h2><a class="anchor" id="sec_argcheck"></a>
Argument callbacks</h2>
<p>It is possible to assign a callback to an <a class="el" href="d4/dfb/classTAP_1_1Argument.html" title="Simple argument class. ">TAP::Argument</a> that is called whenever the argument is set. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="d4/dfb/classTAP_1_1Argument.html">TAP::Argument</a> help(<span class="stringliteral">&quot;Show this &amp;help text&quot;</span>);</div>
<div class="line"><a class="code" href="d1/da2/classTAP_1_1ArgumentParser.html">TAP::ArgumentParser</a> parser(help);</div>
<div class="line">help.check([&amp;parser](<span class="keyword">const</span> <a class="code" href="d4/dfb/classTAP_1_1Argument.html">TAP::Argument</a>&amp;) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">    std::cout &lt;&lt; parser.help() &lt;&lt; std::endl; exit(1);</div>
<div class="line">});</div>
</div><!-- fragment --><p> For details see <a class="el" href="d4/dfb/classTAP_1_1Argument.html#a8bb994cd94088303e933acbf05c7e173" title="Set the check function to use. ">TAP::Argument::check()</a> and <a class="el" href="de/dd0/namespaceTAP.html#ae569d5968d59cb36143c1a0fe10ac5d7" title="Function pointer that is used by Argument::check(). ">TAP::ArgumentCheckFunc</a>.</p>
<p>Similarly, <a class="el" href="dd/d29/classTAP_1_1TypedArgument.html" title="Base class for arguments that hold a typed value. ">TAP::TypedArgument</a> also allows for a callback with the value that was set, for example:</p>
<div class="fragment"><div class="line"><a class="code" href="de/d2e/classTAP_1_1ValueArgument.html">TAP::ValueArgument&lt;int&gt;</a> answer(<span class="stringliteral">&quot;Set the &amp;answer&quot;</span>);</div>
<div class="line"><a class="code" href="d1/da2/classTAP_1_1ArgumentParser.html">TAP::ArgumentParser</a> parser(answer);</div>
<div class="line">answer.check([&amp;parser](<span class="keyword">const</span> <a class="code" href="dd/d29/classTAP_1_1TypedArgument.html">TAP::TypedArgument&lt;int&gt;</a>&amp;, <span class="keywordtype">int</span> val) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">    <span class="keywordflow">if</span> (val != 42) {</div>
<div class="line">        <span class="keywordflow">throw</span> <a class="code" href="d2/d5e/classTAP_1_1exception.html">TAP::exception</a>(<span class="stringliteral">&quot;That is not the answer&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><p> For details see <a class="el" href="dd/d29/classTAP_1_1TypedArgument.html#afee483d43a7a65fc75b7628987b923a6" title="See Argument::check() ">TAP::TypedArgument::check()</a> and <a class="el" href="de/dd0/namespaceTAP.html#a1627d2739c8a3eab7a4caf7aefce4ca5" title="Function pointer that is used by ValueArgument::check() ">TAP::TypedArgumentCheckFunc</a>.</p>
<h2><a class="anchor" id="sec_argconstr"></a>
Argument constraints</h2>
<p>Every now and then some arguments can only occur in certain combinations or have some sort of constraint associated with them (aside from the number of occurrences allowed or required, see <a class="el" href="index.html#sec_argreq">Required arguments and argument counts</a>). To specify this, arguments can be added (recursively) into <a class="el" href="d9/dd8/classTAP_1_1ArgumentConstraint.html" title="Argument constraint class. ">TAP::ArgumentConstraint</a> instances, which specify a certain constraint on the occurrences of arguments relative to each other. Most commonly, exactly one argument must be selected out of a group of many.</p>
<p>To specify such a constraint, create an instance of <a class="el" href="d9/dd8/classTAP_1_1ArgumentConstraint.html" title="Argument constraint class. ">TAP::ArgumentConstraint</a>, templated to <a class="el" href="de/dd0/namespaceTAP.html#a84a79d701ff101f455e640bb555b8c84" title="Enumeration of possible argument constraints. ">TAP::ConstraintType</a> to specify which constraint, and add the constrained arguments. For example: </p>
<div class="fragment"><div class="line"><a class="code" href="d4/dfb/classTAP_1_1Argument.html">TAP::Argument</a> left(<span class="stringliteral">&quot;Turn &amp;left&quot;</span>);</div>
<div class="line"><a class="code" href="d4/dfb/classTAP_1_1Argument.html">TAP::Argument</a> right(<span class="stringliteral">&quot;Turn &amp;right&quot;</span>);</div>
<div class="line"><a class="code" href="d9/dd8/classTAP_1_1ArgumentConstraint.html">TAP::ArgumentConstraint&lt;TAP::ConstraintType::One&gt;</a> dir(left, right);</div>
<div class="line"><a class="code" href="d4/dfb/classTAP_1_1Argument.html">TAP::Argument</a> help(<span class="stringliteral">&quot;Show this &amp;help text&quot;</span>);</div>
<div class="line"><a class="code" href="d1/da2/classTAP_1_1ArgumentParser.html">TAP::ArgumentParser</a> parser(dir, help);</div>
</div><!-- fragment --><p>In this example, left and right cannot be set both at the same time. Should either left or right be selected (so selecting neither is invalid), set the constraint as required with set_required().</p>
<p>Note: Be careful when adding arguments that are required to constraints with an upper bound on the number of allowed arguments (such as <a class="el" href="de/dd0/namespaceTAP.html#a84a79d701ff101f455e640bb555b8c84a06c2cea18679d64399783748fa367bdd" title="1: Exactly one argument must be set ">TAP::ConstraintType::One</a>). This can lead to situations where the constraint can never be satisfied, as all of its arguments are required, but the constraint prohibits this.</p>
<h3><a class="anchor" id="sec_argoperators"></a>
Operators</h3>
<p>For the common case of mutually exclusive arguments, the hat operator (binary XOR) has been defined for arguments to create a <a class="el" href="de/dd0/namespaceTAP.html#a84a79d701ff101f455e640bb555b8c84a06c2cea18679d64399783748fa367bdd" title="1: Exactly one argument must be set ">TAP::ConstraintType::One</a> constraint of the given arguments. For example: </p>
<div class="fragment"><div class="line"><a class="code" href="d4/dfb/classTAP_1_1Argument.html">TAP::Argument</a> left(<span class="stringliteral">&quot;Turn &amp;left&quot;</span>);</div>
<div class="line"><a class="code" href="d4/dfb/classTAP_1_1Argument.html">TAP::Argument</a> right(<span class="stringliteral">&quot;Turn &amp;right&quot;</span>);</div>
<div class="line"><a class="code" href="d4/dfb/classTAP_1_1Argument.html">TAP::Argument</a> help(<span class="stringliteral">&quot;Show this &amp;help text&quot;</span>);</div>
<div class="line"><a class="code" href="d1/da2/classTAP_1_1ArgumentParser.html">TAP::ArgumentParser</a> parser(left ^ right, help);</div>
</div><!-- fragment --><p> Similarly, the OR operator (|) is defined for <a class="el" href="de/dd0/namespaceTAP.html#a84a79d701ff101f455e640bb555b8c84aed36a1ef76a59ee3f15180e0441188ad" title="[1,n]: At least one argument must be set ">TAP::ConstraintType::Any</a>, and the AND operator (&amp;) is defined for <a class="el" href="de/dd0/namespaceTAP.html#a84a79d701ff101f455e640bb555b8c84ab1c94ca2fbc3e78fc30069c8d0f01680" title="n: All arguments must be set ">TAP::ConstraintType::All</a>.</p>
<p>Furthermore, unary operators + and - set an argument respectively as required or optional. Thus, in the above example, to require exactly left or right to be set, you can use: </p>
<div class="fragment"><div class="line"><a class="code" href="d1/da2/classTAP_1_1ArgumentParser.html">TAP::ArgumentParser</a> parser(+(left ^ right), help);</div>
</div><!-- fragment --><h2><a class="anchor" id="sec_argparsing"></a>
Parsing arguments</h2>
<p>Parsing arguments is relatively straight-forward. After defining all arguments and an argument parser, with the arguments added to the parser, simply invoke <a class="el" href="d1/da2/classTAP_1_1ArgumentParser.html#a1ae84d587c31e8d9a6b44247353b33be" title="Parses the given arguments as they are presented on main() (see the parsing rules in the description ...">TAP::ArgumentParser::parse</a> and done. If an error occurs, an exception of the type <a class="el" href="d2/d5e/classTAP_1_1exception.html" title="Standard exception class for TAP. ">TAP::exception</a> (or a subclass thereof) will be thrown. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    <a class="code" href="d4/dfb/classTAP_1_1Argument.html">TAP::Argument</a> help(<span class="stringliteral">&quot;Show this &amp;help text&quot;</span>);</div>
<div class="line">    <a class="code" href="d4/dfb/classTAP_1_1Argument.html">TAP::Argument</a> version(<span class="stringliteral">&quot;Show &amp;version information&quot;</span>);</div>
<div class="line">    <a class="code" href="d1/da2/classTAP_1_1ArgumentParser.html">TAP::ArgumentParser</a> parser(help, version);</div>
<div class="line">    parser.parse(argc, argv);</div>
<div class="line">    <span class="keywordflow">if</span> (help) {</div>
<div class="line">        std::cout &lt;&lt; parser.help() &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(version) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;FIXME&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Arguments can be added either in the constructor, or using the <a class="el" href="d1/da2/classTAP_1_1ArgumentParser.html#a0bfe9a5d555f0d0798c2e3b7dd007ba5" title="Add the given argument, or constraint, to the parser. ">TAP::ArgumentParser::add()</a> method.</p>
<h3><a class="anchor" id="sec_arggroups"></a>
Argument groups</h3>
<p>To group arguments (useful mostly for the help text) a <a class="el" href="d1/dd4/classTAP_1_1ArgumentSet.html" title="Simple set of arguments. ">TAP::ArgumentSet</a> can be created (similar to a constraint), with a given name. When added to the parser, its children are grouped separately in the help text.</p>
<h2><a class="anchor" id="argtest_sec"></a>
Argument testing and value retrieval</h2>
<p>To determine if an argument is set, converting to bool is possible, e.g. </p>
<div class="fragment"><div class="line"><a class="code" href="d4/dfb/classTAP_1_1Argument.html">TAP::Argument</a> myArg(<span class="stringliteral">&quot;&amp;test&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (myArg) {</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> Keep in mind that for arguments that actually store a bool, this is not the same as its value.</p>
<p>To get the number of occurrences, see the <a class="el" href="d4/dfb/classTAP_1_1Argument.html#a1275e07fab1cf9c0fd75db8724822737" title="See BaseArgument::count() ">TAP::Argument::count()</a> method. For <a class="el" href="dd/d29/classTAP_1_1TypedArgument.html" title="Base class for arguments that hold a typed value. ">TAP::TypedArgument</a> instances, the value can be retrieved using <a class="el" href="dd/d29/classTAP_1_1TypedArgument.html#ae3afb4d47c90dcfc9b07460a13521def" title="Returns the value of this argument. ">TAP::TypedArgument::value()</a>. Note that for Multi valued arguments, the value is automatically set to a vector.</p>
<h1><a class="anchor" id="sec_config"></a>
Configuration</h1>
<p><a class="el" href="de/dd0/namespaceTAP.html" title="The main TAP namespace. ">TAP</a> allows for some configuration in the main header file. The following settings alter some of its behavior:</p>
<ul>
<li>TAP_STREAMSAFE : When defined, the default stream operator will defer writing to a stored variable until the input is considered valid. This prevents the variable from being modified if the input is not valid. Note that this requires stored variables to allow copy or move construction.</li>
<li>TAP_AUTOFLAG : When defined, try to parse the description string to find flag and/or name markers. See also <a class="el" href="d4/dfb/classTAP_1_1Argument.html#a3a174d0564f55efb4e022e60f10f56c2" title="When TAP_AUTOFLAG is defined, this function finds flag and/or name markers in the description of the ...">TAP::Argument::parse_description()</a>.</li>
</ul>
<p>Aside from these options, other defines allow some of the syntax to be tweaked (see <a class="el" href="d6/db2/Tap_8h.html" title="Copyright (c) 2015 Harold Bruintjes. ">Tap.h</a> for more details):</p>
<ul>
<li>TAP_FLAG : Defines the string for <a class="el" href="de/dd0/namespaceTAP.html#a6c5d4024b89164d108f217e00dce06d8" title="Marker for flags (one letter arg) ">TAP::flagStart</a></li>
<li>TAP_NAME : Defines the string for <a class="el" href="de/dd0/namespaceTAP.html#ae4f17ec2c1e04ae1b6f86ba83fb46813" title="Marker for names (&gt;1 letter arg) ">TAP::nameStart</a></li>
<li>TAP_NAMEDELIMITER : Defines the string for <a class="el" href="de/dd0/namespaceTAP.html#a94aa023cf3fac569ba960d0baa7b657b" title="Delimiter between name and argument (e.g. ">TAP::nameDelim</a></li>
<li>TAP_SKIP: Defines the string for <a class="el" href="de/dd0/namespaceTAP.html#a4bbefa5a16ff9eed7eac8c339c12e4dc" title="Define the parsed arg delimiter. ">TAP::skip</a></li>
</ul>
<h1><a class="anchor" id="sec_quirks"></a>
Quirks</h1>
<p>Though the library is intended to use relatively easy to use, it may not always do what is expected. Some quirks are listed here:</p>
<ul>
<li>Arguments are stored as copies inside the parser, constraints and groups. Thus, adding an argument to the parser and modifying it afterwards does not work as one may expect. However, copies of arguments will share the same occurrence counter and value, thus adding an argument without modification to multiple constraints will still work.</li>
<li>No argument duplication checks are made. If you add an argument (or two different arguments) with the same alias to the parser, constraint or group, the library will not generate an error. This is useful for the case where an argument occurs in multiple constraints (as they are stored as copies, see above point), but may yield surprising results otherwise. The parser will try to find arguments in the order they were added, so the first added argument has priority. However, if that argument is already set its maximum amount of times, it will look for the next. Only if that fails an error is generated.</li>
<li>The point above also implies something else: It is possible to add multiple positional arguments that can occur many times. In that case, only the first argument added will receive values.</li>
</ul>
<h1><a class="anchor" id="sec_issues"></a>
Known issues</h1>
<ul>
<li>VariableArgument overload resolution kind of wonky</li>
<li>Help text argument sorting and duplicates, also no skip marker</li>
<li>Not particularly high performance </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Oct 4 2015 00:13:04 for TAP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
